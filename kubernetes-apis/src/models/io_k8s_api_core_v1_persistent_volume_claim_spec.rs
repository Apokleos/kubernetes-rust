/* 
 * Kubernetes
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: v1.13.2
 * 
 * Generated by: https://openapi-generator.tech
 */

/// IoK8sApiCoreV1PersistentVolumeClaimSpec : PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct IoK8sApiCoreV1PersistentVolumeClaimSpec {
  /// AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  #[serde(rename = "accessModes")]
  access_modes: Option<Vec<String>>,
  #[serde(rename = "dataSource")]
  data_source: Option<::models::IoK8sApiCoreV1TypedLocalObjectReference>,
  #[serde(rename = "resources")]
  resources: Option<::models::IoK8sApiCoreV1ResourceRequirements>,
  #[serde(rename = "selector")]
  selector: Option<::models::IoK8sApimachineryPkgApisMetaV1LabelSelector>,
  /// Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  #[serde(rename = "storageClassName")]
  storage_class_name: Option<String>,
  /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
  #[serde(rename = "volumeMode")]
  volume_mode: Option<String>,
  /// VolumeName is the binding reference to the PersistentVolume backing this claim.
  #[serde(rename = "volumeName")]
  volume_name: Option<String>
}

impl IoK8sApiCoreV1PersistentVolumeClaimSpec {
  /// PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes
  pub fn new() -> IoK8sApiCoreV1PersistentVolumeClaimSpec {
    IoK8sApiCoreV1PersistentVolumeClaimSpec {
      access_modes: None,
      data_source: None,
      resources: None,
      selector: None,
      storage_class_name: None,
      volume_mode: None,
      volume_name: None
    }
  }

  pub fn set_access_modes(&mut self, access_modes: Vec<String>) {
    self.access_modes = Some(access_modes);
  }

  pub fn with_access_modes(mut self, access_modes: Vec<String>) -> IoK8sApiCoreV1PersistentVolumeClaimSpec {
    self.access_modes = Some(access_modes);
    self
  }

  pub fn access_modes(&self) -> Option<&Vec<String>> {
    self.access_modes.as_ref()
  }

  pub fn reset_access_modes(&mut self) {
    self.access_modes = None;
  }

  pub fn set_data_source(&mut self, data_source: ::models::IoK8sApiCoreV1TypedLocalObjectReference) {
    self.data_source = Some(data_source);
  }

  pub fn with_data_source(mut self, data_source: ::models::IoK8sApiCoreV1TypedLocalObjectReference) -> IoK8sApiCoreV1PersistentVolumeClaimSpec {
    self.data_source = Some(data_source);
    self
  }

  pub fn data_source(&self) -> Option<&::models::IoK8sApiCoreV1TypedLocalObjectReference> {
    self.data_source.as_ref()
  }

  pub fn reset_data_source(&mut self) {
    self.data_source = None;
  }

  pub fn set_resources(&mut self, resources: ::models::IoK8sApiCoreV1ResourceRequirements) {
    self.resources = Some(resources);
  }

  pub fn with_resources(mut self, resources: ::models::IoK8sApiCoreV1ResourceRequirements) -> IoK8sApiCoreV1PersistentVolumeClaimSpec {
    self.resources = Some(resources);
    self
  }

  pub fn resources(&self) -> Option<&::models::IoK8sApiCoreV1ResourceRequirements> {
    self.resources.as_ref()
  }

  pub fn reset_resources(&mut self) {
    self.resources = None;
  }

  pub fn set_selector(&mut self, selector: ::models::IoK8sApimachineryPkgApisMetaV1LabelSelector) {
    self.selector = Some(selector);
  }

  pub fn with_selector(mut self, selector: ::models::IoK8sApimachineryPkgApisMetaV1LabelSelector) -> IoK8sApiCoreV1PersistentVolumeClaimSpec {
    self.selector = Some(selector);
    self
  }

  pub fn selector(&self) -> Option<&::models::IoK8sApimachineryPkgApisMetaV1LabelSelector> {
    self.selector.as_ref()
  }

  pub fn reset_selector(&mut self) {
    self.selector = None;
  }

  pub fn set_storage_class_name(&mut self, storage_class_name: String) {
    self.storage_class_name = Some(storage_class_name);
  }

  pub fn with_storage_class_name(mut self, storage_class_name: String) -> IoK8sApiCoreV1PersistentVolumeClaimSpec {
    self.storage_class_name = Some(storage_class_name);
    self
  }

  pub fn storage_class_name(&self) -> Option<&String> {
    self.storage_class_name.as_ref()
  }

  pub fn reset_storage_class_name(&mut self) {
    self.storage_class_name = None;
  }

  pub fn set_volume_mode(&mut self, volume_mode: String) {
    self.volume_mode = Some(volume_mode);
  }

  pub fn with_volume_mode(mut self, volume_mode: String) -> IoK8sApiCoreV1PersistentVolumeClaimSpec {
    self.volume_mode = Some(volume_mode);
    self
  }

  pub fn volume_mode(&self) -> Option<&String> {
    self.volume_mode.as_ref()
  }

  pub fn reset_volume_mode(&mut self) {
    self.volume_mode = None;
  }

  pub fn set_volume_name(&mut self, volume_name: String) {
    self.volume_name = Some(volume_name);
  }

  pub fn with_volume_name(mut self, volume_name: String) -> IoK8sApiCoreV1PersistentVolumeClaimSpec {
    self.volume_name = Some(volume_name);
    self
  }

  pub fn volume_name(&self) -> Option<&String> {
    self.volume_name.as_ref()
  }

  pub fn reset_volume_name(&mut self) {
    self.volume_name = None;
  }

}



