/* 
 * Kubernetes
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: v1.13.2
 * 
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;

use reqwest;

use super::{Error, configuration};

pub struct CoreV1ApiClient {
    configuration: Rc<configuration::Configuration>,
}

impl CoreV1ApiClient {
    pub fn new(configuration: Rc<configuration::Configuration>) -> CoreV1ApiClient {
        CoreV1ApiClient {
            configuration: configuration,
        }
    }
}

pub trait CoreV1Api {
    fn connect_core_v1_delete_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_delete_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_delete_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_delete_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_delete_node_proxy(&self, name: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_delete_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_get_namespaced_pod_attach(&self, name: &str, namespace: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Result<String, Error>;
    fn connect_core_v1_get_namespaced_pod_exec(&self, name: &str, namespace: &str, command: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Result<String, Error>;
    fn connect_core_v1_get_namespaced_pod_portforward(&self, name: &str, namespace: &str, ports: i32) -> Result<String, Error>;
    fn connect_core_v1_get_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_get_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_get_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_get_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_get_node_proxy(&self, name: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_get_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_head_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_head_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_head_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_head_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_head_node_proxy(&self, name: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_head_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_patch_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_patch_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_patch_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_patch_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_patch_node_proxy(&self, name: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_patch_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_post_namespaced_pod_attach(&self, name: &str, namespace: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Result<String, Error>;
    fn connect_core_v1_post_namespaced_pod_exec(&self, name: &str, namespace: &str, command: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Result<String, Error>;
    fn connect_core_v1_post_namespaced_pod_portforward(&self, name: &str, namespace: &str, ports: i32) -> Result<String, Error>;
    fn connect_core_v1_post_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_post_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_post_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_post_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_post_node_proxy(&self, name: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_post_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_put_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_put_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_put_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_put_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn connect_core_v1_put_node_proxy(&self, name: &str, path: &str) -> Result<String, Error>;
    fn connect_core_v1_put_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Result<String, Error>;
    fn create_core_v1_namespace(&self, io_k8s_api_core_v1_namespace: ::models::IoK8sApiCoreV1Namespace, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error>;
    fn create_core_v1_namespaced_binding(&self, namespace: &str, io_k8s_api_core_v1_binding: ::models::IoK8sApiCoreV1Binding, dry_run: &str, include_uninitialized: bool, pretty: &str) -> Result<::models::IoK8sApiCoreV1Binding, Error>;
    fn create_core_v1_namespaced_config_map(&self, namespace: &str, io_k8s_api_core_v1_config_map: ::models::IoK8sApiCoreV1ConfigMap, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ConfigMap, Error>;
    fn create_core_v1_namespaced_endpoints(&self, namespace: &str, io_k8s_api_core_v1_endpoints: ::models::IoK8sApiCoreV1Endpoints, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Endpoints, Error>;
    fn create_core_v1_namespaced_event(&self, namespace: &str, io_k8s_api_core_v1_event: ::models::IoK8sApiCoreV1Event, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Event, Error>;
    fn create_core_v1_namespaced_limit_range(&self, namespace: &str, io_k8s_api_core_v1_limit_range: ::models::IoK8sApiCoreV1LimitRange, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1LimitRange, Error>;
    fn create_core_v1_namespaced_persistent_volume_claim(&self, namespace: &str, io_k8s_api_core_v1_persistent_volume_claim: ::models::IoK8sApiCoreV1PersistentVolumeClaim, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error>;
    fn create_core_v1_namespaced_pod(&self, namespace: &str, io_k8s_api_core_v1_pod: ::models::IoK8sApiCoreV1Pod, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Pod, Error>;
    fn create_core_v1_namespaced_pod_binding(&self, name: &str, namespace: &str, io_k8s_api_core_v1_binding: ::models::IoK8sApiCoreV1Binding, dry_run: &str, include_uninitialized: bool, pretty: &str) -> Result<::models::IoK8sApiCoreV1Binding, Error>;
    fn create_core_v1_namespaced_pod_eviction(&self, name: &str, namespace: &str, io_k8s_api_policy_v1beta1_eviction: ::models::IoK8sApiPolicyV1beta1Eviction, dry_run: &str, include_uninitialized: bool, pretty: &str) -> Result<::models::IoK8sApiPolicyV1beta1Eviction, Error>;
    fn create_core_v1_namespaced_pod_template(&self, namespace: &str, io_k8s_api_core_v1_pod_template: ::models::IoK8sApiCoreV1PodTemplate, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PodTemplate, Error>;
    fn create_core_v1_namespaced_replication_controller(&self, namespace: &str, io_k8s_api_core_v1_replication_controller: ::models::IoK8sApiCoreV1ReplicationController, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error>;
    fn create_core_v1_namespaced_resource_quota(&self, namespace: &str, io_k8s_api_core_v1_resource_quota: ::models::IoK8sApiCoreV1ResourceQuota, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error>;
    fn create_core_v1_namespaced_secret(&self, namespace: &str, io_k8s_api_core_v1_secret: ::models::IoK8sApiCoreV1Secret, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Secret, Error>;
    fn create_core_v1_namespaced_service(&self, namespace: &str, io_k8s_api_core_v1_service: ::models::IoK8sApiCoreV1Service, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Service, Error>;
    fn create_core_v1_namespaced_service_account(&self, namespace: &str, io_k8s_api_core_v1_service_account: ::models::IoK8sApiCoreV1ServiceAccount, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ServiceAccount, Error>;
    fn create_core_v1_node(&self, io_k8s_api_core_v1_node: ::models::IoK8sApiCoreV1Node, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Node, Error>;
    fn create_core_v1_persistent_volume(&self, io_k8s_api_core_v1_persistent_volume: ::models::IoK8sApiCoreV1PersistentVolume, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error>;
    fn delete_core_v1_collection_namespaced_config_map(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_collection_namespaced_endpoints(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_collection_namespaced_event(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_collection_namespaced_limit_range(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_collection_namespaced_persistent_volume_claim(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_collection_namespaced_pod(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_collection_namespaced_pod_template(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_collection_namespaced_replication_controller(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_collection_namespaced_resource_quota(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_collection_namespaced_secret(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_collection_namespaced_service_account(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_collection_node(&self, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_collection_persistent_volume(&self, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespace(&self, name: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespaced_config_map(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespaced_endpoints(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespaced_event(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespaced_limit_range(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespaced_pod(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespaced_pod_template(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespaced_replication_controller(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespaced_resource_quota(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespaced_secret(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespaced_service(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_namespaced_service_account(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_node(&self, name: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn delete_core_v1_persistent_volume(&self, name: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error>;
    fn get_core_v1_api_resources(&self, ) -> Result<::models::IoK8sApimachineryPkgApisMetaV1ApiResourceList, Error>;
    fn list_core_v1_component_status(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ComponentStatusList, Error>;
    fn list_core_v1_config_map_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ConfigMapList, Error>;
    fn list_core_v1_endpoints_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1EndpointsList, Error>;
    fn list_core_v1_event_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1EventList, Error>;
    fn list_core_v1_limit_range_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1LimitRangeList, Error>;
    fn list_core_v1_namespace(&self, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1NamespaceList, Error>;
    fn list_core_v1_namespaced_config_map(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ConfigMapList, Error>;
    fn list_core_v1_namespaced_endpoints(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1EndpointsList, Error>;
    fn list_core_v1_namespaced_event(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1EventList, Error>;
    fn list_core_v1_namespaced_limit_range(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1LimitRangeList, Error>;
    fn list_core_v1_namespaced_persistent_volume_claim(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaimList, Error>;
    fn list_core_v1_namespaced_pod(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PodList, Error>;
    fn list_core_v1_namespaced_pod_template(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PodTemplateList, Error>;
    fn list_core_v1_namespaced_replication_controller(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ReplicationControllerList, Error>;
    fn list_core_v1_namespaced_resource_quota(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ResourceQuotaList, Error>;
    fn list_core_v1_namespaced_secret(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1SecretList, Error>;
    fn list_core_v1_namespaced_service(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ServiceList, Error>;
    fn list_core_v1_namespaced_service_account(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ServiceAccountList, Error>;
    fn list_core_v1_node(&self, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1NodeList, Error>;
    fn list_core_v1_persistent_volume(&self, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PersistentVolumeList, Error>;
    fn list_core_v1_persistent_volume_claim_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaimList, Error>;
    fn list_core_v1_pod_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PodList, Error>;
    fn list_core_v1_pod_template_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PodTemplateList, Error>;
    fn list_core_v1_replication_controller_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ReplicationControllerList, Error>;
    fn list_core_v1_resource_quota_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ResourceQuotaList, Error>;
    fn list_core_v1_secret_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1SecretList, Error>;
    fn list_core_v1_service_account_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ServiceAccountList, Error>;
    fn list_core_v1_service_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ServiceList, Error>;
    fn patch_core_v1_namespace(&self, name: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error>;
    fn patch_core_v1_namespace_status(&self, name: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error>;
    fn patch_core_v1_namespaced_config_map(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ConfigMap, Error>;
    fn patch_core_v1_namespaced_endpoints(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Endpoints, Error>;
    fn patch_core_v1_namespaced_event(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Event, Error>;
    fn patch_core_v1_namespaced_limit_range(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1LimitRange, Error>;
    fn patch_core_v1_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error>;
    fn patch_core_v1_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error>;
    fn patch_core_v1_namespaced_pod(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Pod, Error>;
    fn patch_core_v1_namespaced_pod_status(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Pod, Error>;
    fn patch_core_v1_namespaced_pod_template(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PodTemplate, Error>;
    fn patch_core_v1_namespaced_replication_controller(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error>;
    fn patch_core_v1_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiAutoscalingV1Scale, Error>;
    fn patch_core_v1_namespaced_replication_controller_status(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error>;
    fn patch_core_v1_namespaced_resource_quota(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error>;
    fn patch_core_v1_namespaced_resource_quota_status(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error>;
    fn patch_core_v1_namespaced_secret(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Secret, Error>;
    fn patch_core_v1_namespaced_service(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Service, Error>;
    fn patch_core_v1_namespaced_service_account(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ServiceAccount, Error>;
    fn patch_core_v1_namespaced_service_status(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Service, Error>;
    fn patch_core_v1_node(&self, name: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Node, Error>;
    fn patch_core_v1_node_status(&self, name: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Node, Error>;
    fn patch_core_v1_persistent_volume(&self, name: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error>;
    fn patch_core_v1_persistent_volume_status(&self, name: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error>;
    fn read_core_v1_component_status(&self, name: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1ComponentStatus, Error>;
    fn read_core_v1_namespace(&self, name: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Namespace, Error>;
    fn read_core_v1_namespace_status(&self, name: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error>;
    fn read_core_v1_namespaced_config_map(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1ConfigMap, Error>;
    fn read_core_v1_namespaced_endpoints(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Endpoints, Error>;
    fn read_core_v1_namespaced_event(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Event, Error>;
    fn read_core_v1_namespaced_limit_range(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1LimitRange, Error>;
    fn read_core_v1_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error>;
    fn read_core_v1_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error>;
    fn read_core_v1_namespaced_pod(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Pod, Error>;
    fn read_core_v1_namespaced_pod_log(&self, name: &str, namespace: &str, container: &str, follow: bool, limit_bytes: i32, pretty: &str, previous: bool, since_seconds: i32, tail_lines: i32, timestamps: bool) -> Result<String, Error>;
    fn read_core_v1_namespaced_pod_status(&self, name: &str, namespace: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1Pod, Error>;
    fn read_core_v1_namespaced_pod_template(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1PodTemplate, Error>;
    fn read_core_v1_namespaced_replication_controller(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error>;
    fn read_core_v1_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, pretty: &str) -> Result<::models::IoK8sApiAutoscalingV1Scale, Error>;
    fn read_core_v1_namespaced_replication_controller_status(&self, name: &str, namespace: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error>;
    fn read_core_v1_namespaced_resource_quota(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error>;
    fn read_core_v1_namespaced_resource_quota_status(&self, name: &str, namespace: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error>;
    fn read_core_v1_namespaced_secret(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Secret, Error>;
    fn read_core_v1_namespaced_service(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Service, Error>;
    fn read_core_v1_namespaced_service_account(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1ServiceAccount, Error>;
    fn read_core_v1_namespaced_service_status(&self, name: &str, namespace: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1Service, Error>;
    fn read_core_v1_node(&self, name: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Node, Error>;
    fn read_core_v1_node_status(&self, name: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1Node, Error>;
    fn read_core_v1_persistent_volume(&self, name: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error>;
    fn read_core_v1_persistent_volume_status(&self, name: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error>;
    fn replace_core_v1_namespace(&self, name: &str, io_k8s_api_core_v1_namespace: ::models::IoK8sApiCoreV1Namespace, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error>;
    fn replace_core_v1_namespace_finalize(&self, name: &str, io_k8s_api_core_v1_namespace: ::models::IoK8sApiCoreV1Namespace, dry_run: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error>;
    fn replace_core_v1_namespace_status(&self, name: &str, io_k8s_api_core_v1_namespace: ::models::IoK8sApiCoreV1Namespace, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error>;
    fn replace_core_v1_namespaced_config_map(&self, name: &str, namespace: &str, io_k8s_api_core_v1_config_map: ::models::IoK8sApiCoreV1ConfigMap, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ConfigMap, Error>;
    fn replace_core_v1_namespaced_endpoints(&self, name: &str, namespace: &str, io_k8s_api_core_v1_endpoints: ::models::IoK8sApiCoreV1Endpoints, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Endpoints, Error>;
    fn replace_core_v1_namespaced_event(&self, name: &str, namespace: &str, io_k8s_api_core_v1_event: ::models::IoK8sApiCoreV1Event, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Event, Error>;
    fn replace_core_v1_namespaced_limit_range(&self, name: &str, namespace: &str, io_k8s_api_core_v1_limit_range: ::models::IoK8sApiCoreV1LimitRange, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1LimitRange, Error>;
    fn replace_core_v1_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, io_k8s_api_core_v1_persistent_volume_claim: ::models::IoK8sApiCoreV1PersistentVolumeClaim, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error>;
    fn replace_core_v1_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, io_k8s_api_core_v1_persistent_volume_claim: ::models::IoK8sApiCoreV1PersistentVolumeClaim, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error>;
    fn replace_core_v1_namespaced_pod(&self, name: &str, namespace: &str, io_k8s_api_core_v1_pod: ::models::IoK8sApiCoreV1Pod, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Pod, Error>;
    fn replace_core_v1_namespaced_pod_status(&self, name: &str, namespace: &str, io_k8s_api_core_v1_pod: ::models::IoK8sApiCoreV1Pod, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Pod, Error>;
    fn replace_core_v1_namespaced_pod_template(&self, name: &str, namespace: &str, io_k8s_api_core_v1_pod_template: ::models::IoK8sApiCoreV1PodTemplate, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PodTemplate, Error>;
    fn replace_core_v1_namespaced_replication_controller(&self, name: &str, namespace: &str, io_k8s_api_core_v1_replication_controller: ::models::IoK8sApiCoreV1ReplicationController, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error>;
    fn replace_core_v1_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, io_k8s_api_autoscaling_v1_scale: ::models::IoK8sApiAutoscalingV1Scale, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiAutoscalingV1Scale, Error>;
    fn replace_core_v1_namespaced_replication_controller_status(&self, name: &str, namespace: &str, io_k8s_api_core_v1_replication_controller: ::models::IoK8sApiCoreV1ReplicationController, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error>;
    fn replace_core_v1_namespaced_resource_quota(&self, name: &str, namespace: &str, io_k8s_api_core_v1_resource_quota: ::models::IoK8sApiCoreV1ResourceQuota, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error>;
    fn replace_core_v1_namespaced_resource_quota_status(&self, name: &str, namespace: &str, io_k8s_api_core_v1_resource_quota: ::models::IoK8sApiCoreV1ResourceQuota, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error>;
    fn replace_core_v1_namespaced_secret(&self, name: &str, namespace: &str, io_k8s_api_core_v1_secret: ::models::IoK8sApiCoreV1Secret, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Secret, Error>;
    fn replace_core_v1_namespaced_service(&self, name: &str, namespace: &str, io_k8s_api_core_v1_service: ::models::IoK8sApiCoreV1Service, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Service, Error>;
    fn replace_core_v1_namespaced_service_account(&self, name: &str, namespace: &str, io_k8s_api_core_v1_service_account: ::models::IoK8sApiCoreV1ServiceAccount, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ServiceAccount, Error>;
    fn replace_core_v1_namespaced_service_status(&self, name: &str, namespace: &str, io_k8s_api_core_v1_service: ::models::IoK8sApiCoreV1Service, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Service, Error>;
    fn replace_core_v1_node(&self, name: &str, io_k8s_api_core_v1_node: ::models::IoK8sApiCoreV1Node, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Node, Error>;
    fn replace_core_v1_node_status(&self, name: &str, io_k8s_api_core_v1_node: ::models::IoK8sApiCoreV1Node, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Node, Error>;
    fn replace_core_v1_persistent_volume(&self, name: &str, io_k8s_api_core_v1_persistent_volume: ::models::IoK8sApiCoreV1PersistentVolume, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error>;
    fn replace_core_v1_persistent_volume_status(&self, name: &str, io_k8s_api_core_v1_persistent_volume: ::models::IoK8sApiCoreV1PersistentVolume, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error>;
    fn watch_core_v1_config_map_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_endpoints_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_event_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_limit_range_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespace(&self, name: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespace_list(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_config_map(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_config_map_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_endpoints(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_endpoints_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_event(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_event_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_limit_range(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_limit_range_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_persistent_volume_claim_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_pod(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_pod_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_pod_template(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_pod_template_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_replication_controller(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_replication_controller_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_resource_quota(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_resource_quota_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_secret(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_secret_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_service(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_service_account(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_service_account_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_namespaced_service_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_node(&self, name: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_node_list(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_persistent_volume(&self, name: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_persistent_volume_claim_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_persistent_volume_list(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_pod_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_pod_template_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_replication_controller_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_resource_quota_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_secret_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_service_account_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
    fn watch_core_v1_service_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error>;
}


impl CoreV1Api for CoreV1ApiClient {
    fn connect_core_v1_delete_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_delete_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, namespace=namespace, path=path);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_delete_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_delete_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, namespace=namespace, path=path);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_delete_node_proxy(&self, name: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_delete_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, path=path);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_get_namespaced_pod_attach(&self, name: &str, namespace: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("container", &container.to_string());
            query.append_pair("stderr", &stderr.to_string());
            query.append_pair("stdin", &stdin.to_string());
            query.append_pair("stdout", &stdout.to_string());
            query.append_pair("tty", &tty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/attach?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_get_namespaced_pod_exec(&self, name: &str, namespace: &str, command: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("command", &command.to_string());
            query.append_pair("container", &container.to_string());
            query.append_pair("stderr", &stderr.to_string());
            query.append_pair("stdin", &stdin.to_string());
            query.append_pair("stdout", &stdout.to_string());
            query.append_pair("tty", &tty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/exec?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_get_namespaced_pod_portforward(&self, name: &str, namespace: &str, ports: i32) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("ports", &ports.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/portforward?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_get_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_get_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, namespace=namespace, path=path);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_get_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_get_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, namespace=namespace, path=path);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_get_node_proxy(&self, name: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_get_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, path=path);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_head_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.head(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_head_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, namespace=namespace, path=path);

        let mut req_builder = client.head(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_head_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.head(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_head_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, namespace=namespace, path=path);

        let mut req_builder = client.head(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_head_node_proxy(&self, name: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.head(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_head_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, path=path);

        let mut req_builder = client.head(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_patch_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_patch_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, namespace=namespace, path=path);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_patch_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_patch_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, namespace=namespace, path=path);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_patch_node_proxy(&self, name: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_patch_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, path=path);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_post_namespaced_pod_attach(&self, name: &str, namespace: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("container", &container.to_string());
            query.append_pair("stderr", &stderr.to_string());
            query.append_pair("stdin", &stdin.to_string());
            query.append_pair("stdout", &stdout.to_string());
            query.append_pair("tty", &tty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/attach?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_post_namespaced_pod_exec(&self, name: &str, namespace: &str, command: &str, container: &str, stderr: bool, stdin: bool, stdout: bool, tty: bool) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("command", &command.to_string());
            query.append_pair("container", &container.to_string());
            query.append_pair("stderr", &stderr.to_string());
            query.append_pair("stdin", &stdin.to_string());
            query.append_pair("stdout", &stdout.to_string());
            query.append_pair("tty", &tty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/exec?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_post_namespaced_pod_portforward(&self, name: &str, namespace: &str, ports: i32) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("ports", &ports.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/portforward?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_post_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_post_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, namespace=namespace, path=path);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_post_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_post_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, namespace=namespace, path=path);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_post_node_proxy(&self, name: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_post_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, path=path);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_put_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_put_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, namespace=namespace, path=path);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_put_namespaced_service_proxy(&self, name: &str, namespace: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_put_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, namespace=namespace, path=path);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_put_node_proxy(&self, name: &str, path: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn connect_core_v1_put_node_proxy_with_path(&self, name: &str, path: &str, path2: &str) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/proxy/{path}?{}", configuration.base_path, query_string, name=name, path=path);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespace(&self, io_k8s_api_core_v1_namespace: ::models::IoK8sApiCoreV1Namespace, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces?{}", configuration.base_path, query_string);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_namespace);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_binding(&self, namespace: &str, io_k8s_api_core_v1_binding: ::models::IoK8sApiCoreV1Binding, dry_run: &str, include_uninitialized: bool, pretty: &str) -> Result<::models::IoK8sApiCoreV1Binding, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/bindings?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_binding);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_config_map(&self, namespace: &str, io_k8s_api_core_v1_config_map: ::models::IoK8sApiCoreV1ConfigMap, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ConfigMap, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_config_map);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_endpoints(&self, namespace: &str, io_k8s_api_core_v1_endpoints: ::models::IoK8sApiCoreV1Endpoints, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Endpoints, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_endpoints);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_event(&self, namespace: &str, io_k8s_api_core_v1_event: ::models::IoK8sApiCoreV1Event, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Event, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_event);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_limit_range(&self, namespace: &str, io_k8s_api_core_v1_limit_range: ::models::IoK8sApiCoreV1LimitRange, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1LimitRange, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_limit_range);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_persistent_volume_claim(&self, namespace: &str, io_k8s_api_core_v1_persistent_volume_claim: ::models::IoK8sApiCoreV1PersistentVolumeClaim, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_persistent_volume_claim);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_pod(&self, namespace: &str, io_k8s_api_core_v1_pod: ::models::IoK8sApiCoreV1Pod, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Pod, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_pod);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_pod_binding(&self, name: &str, namespace: &str, io_k8s_api_core_v1_binding: ::models::IoK8sApiCoreV1Binding, dry_run: &str, include_uninitialized: bool, pretty: &str) -> Result<::models::IoK8sApiCoreV1Binding, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/binding?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_binding);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_pod_eviction(&self, name: &str, namespace: &str, io_k8s_api_policy_v1beta1_eviction: ::models::IoK8sApiPolicyV1beta1Eviction, dry_run: &str, include_uninitialized: bool, pretty: &str) -> Result<::models::IoK8sApiPolicyV1beta1Eviction, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/eviction?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_policy_v1beta1_eviction);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_pod_template(&self, namespace: &str, io_k8s_api_core_v1_pod_template: ::models::IoK8sApiCoreV1PodTemplate, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PodTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_pod_template);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_replication_controller(&self, namespace: &str, io_k8s_api_core_v1_replication_controller: ::models::IoK8sApiCoreV1ReplicationController, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_replication_controller);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_resource_quota(&self, namespace: &str, io_k8s_api_core_v1_resource_quota: ::models::IoK8sApiCoreV1ResourceQuota, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_resource_quota);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_secret(&self, namespace: &str, io_k8s_api_core_v1_secret: ::models::IoK8sApiCoreV1Secret, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Secret, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_secret);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_service(&self, namespace: &str, io_k8s_api_core_v1_service: ::models::IoK8sApiCoreV1Service, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Service, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_service);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_namespaced_service_account(&self, namespace: &str, io_k8s_api_core_v1_service_account: ::models::IoK8sApiCoreV1ServiceAccount, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ServiceAccount, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_service_account);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_node(&self, io_k8s_api_core_v1_node: ::models::IoK8sApiCoreV1Node, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Node, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes?{}", configuration.base_path, query_string);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_node);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_core_v1_persistent_volume(&self, io_k8s_api_core_v1_persistent_volume: ::models::IoK8sApiCoreV1PersistentVolume, include_uninitialized: bool, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/persistentvolumes?{}", configuration.base_path, query_string);

        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_persistent_volume);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_namespaced_config_map(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_namespaced_endpoints(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_namespaced_event(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_namespaced_limit_range(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_namespaced_persistent_volume_claim(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_namespaced_pod(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_namespaced_pod_template(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_namespaced_replication_controller(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_namespaced_resource_quota(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_namespaced_secret(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_namespaced_service_account(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_node(&self, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes?{}", configuration.base_path, query_string);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_collection_persistent_volume(&self, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/persistentvolumes?{}", configuration.base_path, query_string);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespace(&self, name: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespaced_config_map(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespaced_endpoints(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespaced_event(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespaced_limit_range(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespaced_pod(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespaced_pod_template(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespaced_replication_controller(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespaced_resource_quota(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespaced_secret(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespaced_service(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_namespaced_service_account(&self, name: &str, namespace: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_node(&self, name: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn delete_core_v1_persistent_volume(&self, name: &str, pretty: &str, dry_run: &str, grace_period_seconds: i32, orphan_dependents: bool, propagation_policy: &str, io_k8s_apimachinery_pkg_apis_meta_v1_delete_options: ::models::IoK8sApimachineryPkgApisMetaV1DeleteOptions) -> Result<::models::IoK8sApimachineryPkgApisMetaV1Status, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("gracePeriodSeconds", &grace_period_seconds.to_string());
            query.append_pair("orphanDependents", &orphan_dependents.to_string());
            query.append_pair("propagationPolicy", &propagation_policy.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_delete_options);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn get_core_v1_api_resources(&self, ) -> Result<::models::IoK8sApimachineryPkgApisMetaV1ApiResourceList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_component_status(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ComponentStatusList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/componentstatuses?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_config_map_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ConfigMapList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/configmaps?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_endpoints_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1EndpointsList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/endpoints?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_event_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1EventList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/events?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_limit_range_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1LimitRangeList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/limitranges?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespace(&self, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1NamespaceList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespaced_config_map(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ConfigMapList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespaced_endpoints(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1EndpointsList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespaced_event(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1EventList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespaced_limit_range(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1LimitRangeList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespaced_persistent_volume_claim(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaimList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespaced_pod(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PodList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespaced_pod_template(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PodTemplateList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespaced_replication_controller(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ReplicationControllerList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespaced_resource_quota(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ResourceQuotaList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespaced_secret(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1SecretList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespaced_service(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ServiceList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_namespaced_service_account(&self, namespace: &str, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ServiceAccountList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_node(&self, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1NodeList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_persistent_volume(&self, include_uninitialized: bool, pretty: &str, _continue: &str, field_selector: &str, label_selector: &str, limit: i32, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PersistentVolumeList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/persistentvolumes?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_persistent_volume_claim_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaimList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/persistentvolumeclaims?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_pod_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PodList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/pods?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_pod_template_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1PodTemplateList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/podtemplates?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_replication_controller_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ReplicationControllerList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/replicationcontrollers?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_resource_quota_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ResourceQuotaList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/resourcequotas?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_secret_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1SecretList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/secrets?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_service_account_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ServiceAccountList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/serviceaccounts?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn list_core_v1_service_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApiCoreV1ServiceList, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/services?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespace(&self, name: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespace_status(&self, name: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{name}/status?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_config_map(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ConfigMap, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_endpoints(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Endpoints, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_event(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Event, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_limit_range(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1LimitRange, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_pod(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Pod, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_pod_status(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Pod, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_pod_template(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PodTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_replication_controller(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiAutoscalingV1Scale, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_replication_controller_status(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_resource_quota(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_resource_quota_status(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_secret(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Secret, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_service(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Service, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_service_account(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ServiceAccount, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_namespaced_service_status(&self, name: &str, namespace: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Service, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_node(&self, name: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Node, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_node_status(&self, name: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Node, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/status?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_persistent_volume(&self, name: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn patch_core_v1_persistent_volume_status(&self, name: &str, io_k8s_apimachinery_pkg_apis_meta_v1_patch: ::models::IoK8sApimachineryPkgApisMetaV1Patch, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}/status?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.patch(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_apimachinery_pkg_apis_meta_v1_patch);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_component_status(&self, name: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1ComponentStatus, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/componentstatuses/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespace(&self, name: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Namespace, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespace_status(&self, name: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{name}/status?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_config_map(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1ConfigMap, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_endpoints(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Endpoints, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_event(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Event, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_limit_range(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1LimitRange, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_pod(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Pod, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_pod_log(&self, name: &str, namespace: &str, container: &str, follow: bool, limit_bytes: i32, pretty: &str, previous: bool, since_seconds: i32, tail_lines: i32, timestamps: bool) -> Result<String, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("container", &container.to_string());
            query.append_pair("follow", &follow.to_string());
            query.append_pair("limitBytes", &limit_bytes.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("previous", &previous.to_string());
            query.append_pair("sinceSeconds", &since_seconds.to_string());
            query.append_pair("tailLines", &tail_lines.to_string());
            query.append_pair("timestamps", &timestamps.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/log?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_pod_status(&self, name: &str, namespace: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1Pod, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_pod_template(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1PodTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_replication_controller(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, pretty: &str) -> Result<::models::IoK8sApiAutoscalingV1Scale, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_replication_controller_status(&self, name: &str, namespace: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_resource_quota(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_resource_quota_status(&self, name: &str, namespace: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_secret(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Secret, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_service(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Service, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_service_account(&self, name: &str, namespace: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1ServiceAccount, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_namespaced_service_status(&self, name: &str, namespace: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1Service, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_node(&self, name: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1Node, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_node_status(&self, name: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1Node, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/status?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_persistent_volume(&self, name: &str, pretty: &str, exact: bool, export: bool) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("exact", &exact.to_string());
            query.append_pair("export", &export.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn read_core_v1_persistent_volume_status(&self, name: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}/status?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespace(&self, name: &str, io_k8s_api_core_v1_namespace: ::models::IoK8sApiCoreV1Namespace, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_namespace);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespace_finalize(&self, name: &str, io_k8s_api_core_v1_namespace: ::models::IoK8sApiCoreV1Namespace, dry_run: &str, pretty: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("dryRun", &dry_run.to_string());
            query.append_pair("pretty", &pretty.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{name}/finalize?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_namespace);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespace_status(&self, name: &str, io_k8s_api_core_v1_namespace: ::models::IoK8sApiCoreV1Namespace, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Namespace, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{name}/status?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_namespace);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_config_map(&self, name: &str, namespace: &str, io_k8s_api_core_v1_config_map: ::models::IoK8sApiCoreV1ConfigMap, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ConfigMap, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/configmaps/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_config_map);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_endpoints(&self, name: &str, namespace: &str, io_k8s_api_core_v1_endpoints: ::models::IoK8sApiCoreV1Endpoints, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Endpoints, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/endpoints/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_endpoints);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_event(&self, name: &str, namespace: &str, io_k8s_api_core_v1_event: ::models::IoK8sApiCoreV1Event, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Event, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/events/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_event);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_limit_range(&self, name: &str, namespace: &str, io_k8s_api_core_v1_limit_range: ::models::IoK8sApiCoreV1LimitRange, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1LimitRange, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/limitranges/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_limit_range);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, io_k8s_api_core_v1_persistent_volume_claim: ::models::IoK8sApiCoreV1PersistentVolumeClaim, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_persistent_volume_claim);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, io_k8s_api_core_v1_persistent_volume_claim: ::models::IoK8sApiCoreV1PersistentVolumeClaim, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolumeClaim, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_persistent_volume_claim);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_pod(&self, name: &str, namespace: &str, io_k8s_api_core_v1_pod: ::models::IoK8sApiCoreV1Pod, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Pod, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_pod);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_pod_status(&self, name: &str, namespace: &str, io_k8s_api_core_v1_pod: ::models::IoK8sApiCoreV1Pod, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Pod, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/pods/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_pod);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_pod_template(&self, name: &str, namespace: &str, io_k8s_api_core_v1_pod_template: ::models::IoK8sApiCoreV1PodTemplate, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PodTemplate, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/podtemplates/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_pod_template);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_replication_controller(&self, name: &str, namespace: &str, io_k8s_api_core_v1_replication_controller: ::models::IoK8sApiCoreV1ReplicationController, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_replication_controller);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, io_k8s_api_autoscaling_v1_scale: ::models::IoK8sApiAutoscalingV1Scale, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiAutoscalingV1Scale, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_autoscaling_v1_scale);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_replication_controller_status(&self, name: &str, namespace: &str, io_k8s_api_core_v1_replication_controller: ::models::IoK8sApiCoreV1ReplicationController, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ReplicationController, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_replication_controller);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_resource_quota(&self, name: &str, namespace: &str, io_k8s_api_core_v1_resource_quota: ::models::IoK8sApiCoreV1ResourceQuota, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_resource_quota);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_resource_quota_status(&self, name: &str, namespace: &str, io_k8s_api_core_v1_resource_quota: ::models::IoK8sApiCoreV1ResourceQuota, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ResourceQuota, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/resourcequotas/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_resource_quota);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_secret(&self, name: &str, namespace: &str, io_k8s_api_core_v1_secret: ::models::IoK8sApiCoreV1Secret, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Secret, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/secrets/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_secret);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_service(&self, name: &str, namespace: &str, io_k8s_api_core_v1_service: ::models::IoK8sApiCoreV1Service, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Service, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_service);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_service_account(&self, name: &str, namespace: &str, io_k8s_api_core_v1_service_account: ::models::IoK8sApiCoreV1ServiceAccount, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1ServiceAccount, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/serviceaccounts/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_service_account);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_namespaced_service_status(&self, name: &str, namespace: &str, io_k8s_api_core_v1_service: ::models::IoK8sApiCoreV1Service, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Service, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/namespaces/{namespace}/services/{name}/status?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_service);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_node(&self, name: &str, io_k8s_api_core_v1_node: ::models::IoK8sApiCoreV1Node, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Node, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_node);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_node_status(&self, name: &str, io_k8s_api_core_v1_node: ::models::IoK8sApiCoreV1Node, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1Node, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/nodes/{name}/status?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_node);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_persistent_volume(&self, name: &str, io_k8s_api_core_v1_persistent_volume: ::models::IoK8sApiCoreV1PersistentVolume, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_persistent_volume);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn replace_core_v1_persistent_volume_status(&self, name: &str, io_k8s_api_core_v1_persistent_volume: ::models::IoK8sApiCoreV1PersistentVolume, pretty: &str, dry_run: &str) -> Result<::models::IoK8sApiCoreV1PersistentVolume, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("dryRun", &dry_run.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/persistentvolumes/{name}/status?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        

        req_builder = req_builder.json(&io_k8s_api_core_v1_persistent_volume);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_config_map_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/configmaps?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_endpoints_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/endpoints?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_event_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/events?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_limit_range_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/limitranges?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespace(&self, name: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespace_list(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_config_map(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/configmaps/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_config_map_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/configmaps?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_endpoints(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/endpoints/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_endpoints_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/endpoints?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_event(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/events/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_event_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/events?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_limit_range(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/limitranges/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_limit_range_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/limitranges?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_persistent_volume_claim_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_pod(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/pods/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_pod_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/pods?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_pod_template(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/podtemplates/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_pod_template_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/podtemplates?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_replication_controller(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_replication_controller_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/replicationcontrollers?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_resource_quota(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_resource_quota_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/resourcequotas?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_secret(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/secrets/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_secret_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/secrets?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_service(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/services/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_service_account(&self, name: &str, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}?{}", configuration.base_path, query_string, name=name, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_service_account_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/serviceaccounts?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_namespaced_service_list(&self, namespace: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/namespaces/{namespace}/services?{}", configuration.base_path, query_string, namespace=namespace);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_node(&self, name: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/nodes/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_node_list(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/nodes?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_persistent_volume(&self, name: &str, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/persistentvolumes/{name}?{}", configuration.base_path, query_string, name=name);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_persistent_volume_claim_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/persistentvolumeclaims?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_persistent_volume_list(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/persistentvolumes?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_pod_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/pods?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_pod_template_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/podtemplates?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_replication_controller_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/replicationcontrollers?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_resource_quota_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/resourcequotas?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_secret_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/secrets?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_service_account_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/serviceaccounts?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn watch_core_v1_service_list_for_all_namespaces(&self, _continue: &str, field_selector: &str, include_uninitialized: bool, label_selector: &str, limit: i32, pretty: &str, resource_version: &str, timeout_seconds: i32, watch: bool) -> Result<::models::IoK8sApimachineryPkgApisMetaV1WatchEvent, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("continue", &_continue.to_string());
            query.append_pair("fieldSelector", &field_selector.to_string());
            query.append_pair("includeUninitialized", &include_uninitialized.to_string());
            query.append_pair("labelSelector", &label_selector.to_string());
            query.append_pair("limit", &limit.to_string());
            query.append_pair("pretty", &pretty.to_string());
            query.append_pair("resourceVersion", &resource_version.to_string());
            query.append_pair("timeoutSeconds", &timeout_seconds.to_string());
            query.append_pair("watch", &watch.to_string());

            query.finish()
        };
        let uri_str = format!("{}/api/v1/watch/services?{}", configuration.base_path, query_string);

        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }


        
        if let Some(ref apikey) = configuration.api_key {
            let key = apikey.key.clone();
            let val = match apikey.prefix {
                Some(ref prefix) => format!("{} {}", prefix, key),
                None => key,
            };
            req_builder = req_builder.header("authorization", val);
        };
        


        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

}
